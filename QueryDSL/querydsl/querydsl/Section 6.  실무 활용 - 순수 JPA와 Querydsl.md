### QueryDSL의 장점
[ JPQL 대비 장점 ]
- 컴파일 시점 오류 검출: JPQL은 실행 시점에 오류를 발견하지만, QueryDSL은 컴파일 시점에 검출 가능하다. 
- 직관적이고 간결한 코드: 메서드 체인을 활용해 쿼리를 작성하므로 가독성이 높아진다.
- 파라미터 바인딩 처리 자동화: QueryDSL은 파라미터를 직접 전달받아 처리하므로 바인딩 코드가 줄어든다. <br/>
<br/>

#### 리포지토리에 QueryDSL 적용
- EntityManager: JPA의 핵심 인터페이스로 데이터베이스와 상호작용. 
- JPAQueryFactory: QueryDSL에서 쿼리를 작성하고 실행하는 중심 객체.
- JPAQueryFactory를 스프링 컨텍스트에 빈으로 등록하면 각 리포지토리에서 생성자 주입으로 사용 가능하다. <br/>
  <br/>

### 복잡한 조건 처리: BooleanBuilder 사용
[ BooleanBuilder를 활용한 동적 쿼리 ]

동적 조건 필요성
- 조건이 고정적이지 않고 입력 값에 따라 달라질 경우 BooleanBuilder를 사용해 유연하게 쿼리를 작성한다.

BooleanBuilder의 장점
- 동적 조건 추가: 조건이 null인지 확인 후 and 또는 or로 유연하게 추가 가능하다.
- 코드 재사용성: BooleanBuilder는 조건을 메서드로 분리해 다른 쿼리에서도 재사용 가능하다. <br/>
  <br/>

### QueryDSL과 동시성 문제
QueryDSL 동작 방식
- JPAQueryFactory는 EntityManager를 내부적으로 사용한다.
- 스프링에서 제공하는 EntityManager는 트랜잭션 단위로 분리되어 동작하므로 Thread-safe.
> QueryDSL은 멀티스레드 환경에서도 동시성 문제가 없음.<br/>

<br/>

### 동적 쿼리와 성능 최적화 조회 - Where절 파라미터 사용
- QueryDSL의 where 절에 파라미터 방식으로 조건을 작성하면, 코드 가독성과 재사용성이 높아진다.
- 각 조건을 메서드로 분리하여 필요에 따라 조합 가능하다.

[ 조건 처리 메서드 ]
- 각각의 조건을 BooleanExpression으로 분리하여 코드 재사용성과 가독성을 높일 수 있다.
- null 값 처리는 자동으로 무시되므로, 조건이 없을 경우 쿼리에서 제외된다.

[ Where 절 파라미터 방식의 장점 ]
- 조건의 재사용성 
  - 조건 메서드를 따로 정의하여 다른 쿼리에서도 재활용 가능하다.
  - 예를 들어, DTO 대신 엔티티를 반환하거나 다른 비즈니스 로직에 사용 가능하다.
- 코드의 간결함과 가독성 
  - where 절에 조건 메서드를 조합해 직관적으로 작성 가능하다. 
  - 조건이 많아질수록 효과적이며, 중복 코드가 줄어든다.
- null 값 처리 
  - 조건 메서드에서 null 값이나 빈 문자열("")을 처리하여, 불필요한 조건을 자동으로 제외할 수 있다.