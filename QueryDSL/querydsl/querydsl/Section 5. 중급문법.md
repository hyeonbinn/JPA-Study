## 프로젝션 
#### : 쿼리에서 필요한 특정 필드나 컬럼만 선택적으로 조회하는 것을 의미한다. (select 대상 지정)

- 프로젝션 대상이 하나면 >> 타입을 명확하게 지정할 수 있음
- 프로젝션 대상이 둘 이상이면 >> 튜플이나 DTO로 조회 

<br/>

#### 바깥 계층으로 내보낼 때는 tuple말고 DTO로 던져주자!!
- tuple은 com.querydsl 패키지에 속해있다.
- Repository 계층 내부에서 tuple을 사용하는 것은 문제가 없으나, 그 이상의 레벨 (controller, service 등)로 전달하면 구현 기술(예를 들어 QueryDSL을 사용한다..)이 노출되어 추상화 원칙을 위배하게 된다.
- 즉 tuple을 repository 계층 안에서만 사용하도록 하여 하부 기술을 다른 것으로 바꾸더라도 외부에 영향을 주지 않도록 하는 것이 좋다.
>즉, 외부 계층으로 데이터를 전달할 때는 DTO를 사용해 기술 독립성을 유지해야 한다.

<br/>

### 프로젝션 결과 반환을 DTO로 하는 방법

#### 순수 JPA에서 DTO 조회 코드
- 순수 JPA에서 DTO를 조회할 때는 new 명령어를 사용해야 한다.
- DTO의 package이름을 다 적어줘야해서 지저분하다.
- 생성자 방식만 지원한다. (세터,필드 주입 X ) <br/>
  <br/>

#### Querydsl DTO 조회 코드
> Querydsl DTO 조회 코드는 3가지 방법 모두를 지원한다.
1. 프로퍼티 접근
2. 필드 직접 접근
3. 생성자 사용 
   <br> <br>

#### Setter를 이용한 프로퍼티 접근
- Projections.bean을 사용해 DTO에 데이터를 매핑한다. (반환하고자 하는 타입, 프로젝션할 항목들 순서로 써주면 된다.)
- 조회해보면, 딱 필요한 member, age만 최적화해서 가져오는 것을 확인할 수 있다.
  <br> <br>

#### 필드 직접 접근
- Projections.fields를 사용해 필드에 직접 값을 할당한다. getter나 setter 없이 값을 넣을 수 있다.
- 필드 이름이 DTO와 일치해야 하며, 일치하지 않으면 null로 반환된다. 
- 이름이 다른 경우 .as("필드명") 을 작성해 매핑이 가능하다.
- 서브쿼리나 복잡한 표현식을 사용할 때는 ExpressionUtils.as()를 활용할 수 있다.
<br><br>

#### 생성자 사용
- Projections.constructor를 사용해 생성자를 통해 값을 주입한다.
- 필드 이름이 아닌 타입 기반으로 데이터를 매핑하므로 이름 매칭 오류를 방지할 수 있다.

<br/>

### 프로젝션과 결과 반환 - @QueryProjection
>@QueryProjection은 DTO 클래스에 직접 QueryDSL과 연동 가능한 Q클래스를 생성하도록 설정하는 방법이다.
- MemberDto에 바로 @QueryProjection을 적어주고, Gradle > other > compileQuerydsl을 실행하면,
- DTO도 Q파일로 생성이 된다!! (DTO를 Q객체화 해서 사용 가능)
- 이를 사용할 때 생성자를 그대로 가져오기 때문에 컴파일 시점에 타입 오류를 잡을 수 있어 안정적인 코드를 작성할 수 있다. (cmd+p) 
  - 예를 들어, DTO의 생성자에 잘못된 타입을 전달했을 경우, 런타임이 아닌 컴파일 시점에 오류를 확인할 수 있다.
<br>
- @QueryProjection과 constructor의 차이점은?
  - constructor는 컴파일 시점에 오류를 잡지 못하고, 런타임에 오류를 잡는다.
  - 똑같은 문제를 @QueryProjection를 사용해 해결하면, 컴파일 시점에 오류를 잡아준다. <br>
<br>
- 단점
  - DTO까지 Q파일을 생성해야 하는 추가적인 빌드 작업이 필요하다.
  - Querydsl에 대한 의존성을 가지게 되어, QueryDSL을 제거하거나 다른 라이브러리로 대체하기 어려울 수 있다.

<br/>

### 동적 쿼리를 해결하는 방법
1. BooleanBuilder를 사용하는 방법
2. Where문 안에 다중 파라미터를 사용하는 방법<br>
   <br>

#### BooleanBuilder를 사용하는 방법
>QueryDSL에서 동적 조건을 간편하게 추가할 수 있도록 도와주는 도구이다.
- 우선 BooleanBuilder를 만들어야 한다.(초기 조건을 넣어줄 수도 있다.)
- 특정 조건이 만족되면 and 또는 or 메서드를 사용해 조건을 추가할 수 있따.
- 최종적으로 where절에 BooleanBuilder를 전달해 동적 쿼리를 실행한다. <br>
<br>
- 장점
  - 가독성이 좋고, 조건 추가가 유연하다.
  - 여러 조건을 동적으로 추가할 수 있다.<br>
    <br>

#### Where문 안에 다중 파라미터를 사용하는 방법
- QueryDSL의 where 조건에서는 null 값을 자동으로 무시된다.
  - 예를 들어, usernameParam만 전달되면 해당 조건만 적용된다.
- 조건을 메서드화하여 가독성을 높이고, 쿼리를 다른 곳에서도 재활용할 수 있다. 
- 조건들을 조립하여 한 번에 적용할 수도 있습니다.
  - 조립하려면 Predicate이 아니라 BooleanExpression을 사용해야 한다.
  - null 체크는 주의해서 처리해야 한다.<br>
    <br>

#### 수정, 삭제 배치 쿼리
<벌크 연산이란??>
- 벌크 연산이란 쿼리 한 번으로 여러 데이터에 대해 수정 또는 삭제 작업을 수행하는 것이다.

<장점>
- 대량 데이터에 대해 효율적으로 작업할 수 있어 성능이 뛰어나다.
- 반복적인 업데이트 또는 삭제 작업을 줄일 수 있다.

<주의 사항>
- QueryDSL 벌크 연산은 영속성 컨텍스트를 무시하고 DB에 바로 적용된다.
- JPA에서는 영속성 컨텍스트가 항상 DB보다 우선권을 가진다. 즉, 엔티티가 영속성 컨텍스트에 존재하면 DB에서 값을 조회하더라도 무시되고, 영속성 컨텍스트의 값이 유지된다.
  - DB 상태:
    member1의 username = "비회원" <br/>
    영속성 컨텍스트 상태: member1의 username = "member1"
  - 벌크 연산 실행 이후, 영속성 컨텍스트가 우선권을 가지기 때문에, DB에서 변경된 값("비회원")을 반영하지 않고 영속성 컨텍스트의 값을 사용한다.
  - 즉 영속성 컨텍스트에서 member1의 데이터를 조회하면, 여전히 username이 "member1"로 유지된다.
> 이를 해결하기 위해 벌크 연산 실행 전후에 em.flush()를 호출해 영속성 컨텍스트의 데이터를 먼저 DB에 반영하고, em.clear()를 호출해 영속성 컨텍스트를 초기화해 영속성 컨텍스트와 DB를 동기화해야 한다. (영속성 컨텍스트와 DB 간 데이터 불일치를 방지) <br>

<br>

#### SQL Function 호출하기.
- SQL function은 JPA와 같이 Dialect에 등록된 내용만 호출할 수 있다.
- 코드 예시에서 작성한 lower 같은 ansi 표준 함수들은 querydsl이 상당 부분 내장하고 있다.
